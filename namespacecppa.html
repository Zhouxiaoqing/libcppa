<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libcppa: cppa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cppa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcppa.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecppa_1_1exit__reason"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecppa_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1factory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:namespacecppa_1_1factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains factory functions to create actors from lambdas or other functors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1intrusive"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1intrusive.html">intrusive</a></td></tr>
<tr class="memdesc:namespacecppa_1_1intrusive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains intrusive container implementations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1network"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1network.html">network</a></td></tr>
<tr class="memdesc:namespacecppa_1_1network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all network related classes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1opencl.html">opencl</a></td></tr>
<tr class="memdesc:namespacecppa_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all classes of libcppa's OpenCL binding (optional). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1placeholders"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1placeholders.html">placeholders</a></td></tr>
<tr class="memdesc:namespacecppa_1_1placeholders"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the guard placeholders <code>_x1</code> to <code>_x9</code>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1util"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecppa_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utility classes and metaprogramming utilities used by the libcppa implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcppa_1_1actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__addressing.html">actor_addressing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different serialization protocols have different representations for actors. This class encapsulates a technology-specific actor addressing.  <a href="classcppa_1_1actor__addressing.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__companion__mixin.html">actor_companion_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds co-existing objects (companions) to a class, which serve as gateways, thereby enabling libcppa's message passing.  <a href="classcppa_1_1actor__companion__mixin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote actor.  <a href="classcppa_1_1actor__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length copy-on-write tuple with elements of any type.  <a href="classcppa_1_1any__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1anything.html">anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as wildcard expression in patterns.  <a href="structcppa_1_1anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__anything.html">is_anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wheter <code>T</code> is <a class="el" href="structcppa_1_1anything.html">anything</a>.  <a href="structcppa_1_1is__anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcppa_1_1attachable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor.  <a href="classcppa_1_1behavior.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the deserializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the serializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcppa_1_1channel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1context__switching__actor.html">context_switching_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context-switching actor implementation.  <a href="classcppa_1_1context__switching__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__ptr.html">cow_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy-on-write smart pointer implementation.  <a href="classcppa_1_1cow__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html">cow_tuple&lt; Head, Tail...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-length copy-on-write cow_tuple.  <a href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value of <code>T</code>.  <a href="classcppa_1_1optional.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer impelementation.  <a href="classcppa_1_1intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcppa_1_1deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1enable__weak__ptr.html">enable_weak_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables derived classes to be used in <a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>.  <a href="classcppa_1_1enable__weak__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all event-based actor implementations.  <a href="classcppa_1_1event__based__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cppa__exception.html">cppa_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for libcppa exceptions.  <a href="classcppa_1_1cppa__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__exited.html">actor_exited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown if an actor finished execution.  <a href="classcppa_1_1actor__exited.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1network__error.html">network_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that either an actor publishing failed or <code>libcppa</code> was unable to connect to a remote host.  <a href="classcppa_1_1network__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1bind__failure.html">bind_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that an actor publishing failed because the requested port could not be used.  <a href="classcppa_1_1bind__failure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1extend.html">extend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows convenient definition of types using mixins. For example, <code>extend&lt;ar, T&gt;::with&lt;ob, fo&gt;</code> is an alias for <code>fo&lt;ob&lt;ar, T&gt;</code>, T&gt;.  <a href="structcppa_1_1extend.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcppa_1_1group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for guard expression.  <a href="structcppa_1_1guard__placeholder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for local running Actors.  <a href="classcppa_1_1local__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A match expression encapsulating cases <code>Cs...</code>.  <a href="classcppa_1_1match__expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__cached.html">memory_cached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin adds all member functions and member variables needed by the memory management subsystem.  <a href="classcppa_1_1memory__cached.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__managed.html">memory_managed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base enables derived classes to enforce a different allocation strategy than new/delete by providing a virtual protected <code><a class="el" href="classcppa_1_1memory__managed.html#ae14e5c4be622520c604a9ac69f0c9478" title="Default implementations calls delete this, but can be overriden in case deletion depends on some cond...">request_deletion()</a></code> function and non-public destructor.  <a href="classcppa_1_1memory__managed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1continue__helper.html">continue_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <code>continue_with</code> member function as used in <code>sync_send(...).then(...).continue_with(...)</code>.  <a href="classcppa_1_1continue__helper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__future.html">message_future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the result of a synchronous send.  <a href="classcppa_1_1message__future.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__header.html">message_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates information about sender, receiver and (synchronous) message ID of a message. The message itself is usually an <a class="el" href="classcppa_1_1any__tuple.html" title="Describes a fixed-length copy-on-write tuple with elements of any type. ">any_tuple</a>.  <a href="classcppa_1_1message__header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__id.html">message_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction class that stores an instance of an announced type.  <a href="classcppa_1_1object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1option__info.html">option_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text along with the number of expected arguments.  <a href="structcppa_1_1option__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__optional.html">is_optional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcppa_1_1optional__variant.html" title="A optional_variant is either invalid or holds a value of one of the types Ts. ">optional_variant</a> is either invalid or holds a value of one of the types <code>Ts</code>.  <a href="classcppa_1_1optional__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation for <a class="el" href="classcppa_1_1any__tuple.html">any_tuples</a>.  <a href="classcppa_1_1partial__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An union container for primitive data types.  <a href="classcppa_1_1primitive__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1process__information.html">process_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a process.  <a href="classcppa_1_1process__information.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (thread safe) base class for reference counted objects with an atomic reference count.  <a href="classcppa_1_1ref__counted.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1response__handle.html">response_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes an outstanding response.  <a href="classcppa_1_1response__handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1sb__actor.html">sb_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for state-based actors using the Curiously Recurring Template Pattern to initialize the derived actor with its <code>init_state</code> member.  <a href="classcppa_1_1sb__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for cooperatively scheduled actors.  <a href="classcppa_1_1scheduled__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class allows to create (spawn) new actors and offers delayed sends.  <a href="classcppa_1_1scheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1destination__header.html">destination_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores sender, receiver, and message priority.  <a href="structcppa_1_1destination__header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcppa_1_1serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family.  <a href="classcppa_1_1spawn__options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1stacked.html">stacked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor that uses the blocking API of <code>libcppa</code> and thus needs its own stack.  <a href="classcppa_1_1stacked.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1stackless.html">stackless</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor that uses the non-blocking API of <code>libcppa</code> and does not has its own stack.  <a href="classcppa_1_1stackless.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1thread__mapped__actor.html">thread_mapped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor using the blocking API running in its own thread.  <a href="classcppa_1_1thread__mapped__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1threadless.html">threadless</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor that is scheduled or otherwise managed.  <a href="classcppa_1_1threadless.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1type__lookup__table.html">type_lookup_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="classcppa_1_1object.html">object</a>.  <a href="classcppa_1_1uniform__type__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that does not increase the reference count.  <a href="classcppa_1_1weak__intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__ptr__anchor.html">weak_ptr_anchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage holding a spinlock and a pointer to a reference counted object.  <a href="classcppa_1_1weak__ptr__anchor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a863e1b47946c1de002b6d01a6d02d606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863e1b47946c1de002b6d01a6d02d606"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1actor.html">actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actor_ptr</b></td></tr>
<tr class="separator:a863e1b47946c1de002b6d01a6d02d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beaceb1768c40b55c645612aa93daae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9beaceb1768c40b55c645612aa93daae"></a>
template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a9beaceb1768c40b55c645612aa93daae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9beaceb1768c40b55c645612aa93daae">enable_if_channel</a> = std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classcppa_1_1channel.html">channel</a>, T &gt;::value, R &gt;</td></tr>
<tr class="memdesc:a9beaceb1768c40b55c645612aa93daae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias. <br/></td></tr>
<tr class="separator:a9beaceb1768c40b55c645612aa93daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948e3ea11df8e64e9a0e0204d3d52539"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>native_socket_type</b></td></tr>
<tr class="separator:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8212243ffb4995abddd7850f47863b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8212243ffb4995abddd7850f47863b1"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_send_ptr</b></td></tr>
<tr class="separator:af8212243ffb4995abddd7850f47863b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cea4187e4fa345b7cad0ca5c8e08af"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_recv_ptr</b></td></tr>
<tr class="separator:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ee2cb32752d31e00d020c6cb7362e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ee2cb32752d31e00d020c6cb7362e2"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1group.html">group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>group_ptr</b></td></tr>
<tr class="separator:a60ee2cb32752d31e00d020c6cb7362e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac06fc2f69fb1021d95310238161c4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac06fc2f69fb1021d95310238161c4e"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1channel.html">channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>channel_ptr</b></td></tr>
<tr class="separator:a0ac06fc2f69fb1021d95310238161c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6176abcec9771fe0a6138290da091614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6176abcec9771fe0a6138290da091614"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1process__information.html">process_information</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>process_information_ptr</b></td></tr>
<tr class="separator:a6176abcec9771fe0a6138290da091614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac780fad19465067ad0dc34bc70b5e783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac780fad19465067ad0dc34bc70b5e783"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::map&lt; std::pair&lt; char, <br class="typebreak"/>
std::string &gt;, <a class="el" href="structcppa_1_1option__info.html">option_info</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a></td></tr>
<tr class="memdesc:ac780fad19465067ad0dc34bc70b5e783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text for program options with option groups. <br/></td></tr>
<tr class="separator:ac780fad19465067ad0dc34bc70b5e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce33a4289859c028c999472cc16410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dce33a4289859c028c999472cc16410"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_ptr</b></td></tr>
<tr class="separator:a4dce33a4289859c028c999472cc16410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9c04c4339079df23bb8d6379645fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27d9c04c4339079df23bb8d6379645fa"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1thread__mapped__actor.html">thread_mapped_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>thread_mapped_actor_ptr</b></td></tr>
<tr class="separator:a27d9c04c4339079df23bb8d6379645fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7044eb06e2b94aaf9684d5d31e759f"></a>
typedef timeout_definition<br class="typebreak"/>
&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generic_timeout_definition</b></td></tr>
<tr class="separator:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abbace0a3a35eaf1c4c87d77d9ec29047"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>actor_state</b> : int { <br/>
&#160;&#160;<b>ready</b>, 
<br/>
&#160;&#160;<b>done</b>, 
<br/>
&#160;&#160;<b>blocked</b>, 
<br/>
&#160;&#160;<b>pending</b>, 
<br/>
&#160;&#160;<b>about_to_block</b>
<br/>
 }</td></tr>
<tr class="separator:abbace0a3a35eaf1c4c87d77d9ec29047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64079da560a7bd85135c11ab521a4950"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> : std::uint64_t </td></tr>
<tr class="memdesc:a64079da560a7bd85135c11ab521a4950"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of atoms. <br/></td></tr>
<tr class="separator:a64079da560a7bd85135c11ab521a4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>operator_id</b> { <br/>
&#160;&#160;<b>addition_op</b>, 
<br/>
&#160;&#160;<b>subtraction_op</b>, 
<br/>
&#160;&#160;<b>multiplication_op</b>, 
<br/>
&#160;&#160;<b>division_op</b>, 
<br/>
&#160;&#160;<b>modulo_op</b>, 
<br/>
&#160;&#160;<b>less_op</b>, 
<br/>
&#160;&#160;<b>less_eq_op</b>, 
<br/>
&#160;&#160;<b>greater_op</b>, 
<br/>
&#160;&#160;<b>greater_eq_op</b>, 
<br/>
&#160;&#160;<b>equal_op</b>, 
<br/>
&#160;&#160;<b>not_equal_op</b>, 
<br/>
&#160;&#160;<b>logical_and_op</b>, 
<br/>
&#160;&#160;<b>logical_or_op</b>, 
<br/>
&#160;&#160;<b>exec_fun1_op</b>, 
<br/>
&#160;&#160;<b>exec_fun2_op</b>, 
<br/>
&#160;&#160;<b>exec_fun3_op</b>, 
<br/>
&#160;&#160;<b>exec_xfun_op</b>, 
<br/>
&#160;&#160;<b>dummy_op</b>
<br/>
 }</td></tr>
<tr class="separator:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648afc4427bb8aa7b883b1940ca761ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a648afc4427bb8aa7b883b1940ca761ba">match_hint</a> { <br/>
&#160;&#160;<b>skip</b>, 
<br/>
&#160;&#160;<b>handle</b>
<br/>
 }</td></tr>
<tr class="memdesc:a648afc4427bb8aa7b883b1940ca761ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional return type for functors used in pattern matching expressions. This type is evaluated by the runtime system of libcppa and can be used to intentionally skip messages. <br/></td></tr>
<tr class="separator:a648afc4427bb8aa7b883b1940ca761ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d951cd2881a098549c7393c470c8bee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>message_priority</b> { <br/>
&#160;&#160;<b>normal</b>, 
<br/>
&#160;&#160;<b>high</b>
<br/>
 }</td></tr>
<tr class="separator:a9d951cd2881a098549c7393c470c8bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4405c08180f3db0936dcc6afe84f2899"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> : unsigned char { <br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899af3b4cd07f6e7b784ef327226d125f081">pt_int8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899abe2fbca2e1841f8c22880cde2c00f542">pt_int16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899aa0a3077bf98838f8565a3081bd45fe7a">pt_int32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899adb00d323a0719b09a9b1e2b296bf7ee7">pt_int64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a88cb8022596d4673fede279849a67c9e">pt_uint8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac2fefdb86c724a8fccdaf77295bdb786">pt_uint16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a081be63f60008807f9a07df1d814704a">pt_uint32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a05e7b1ff7b99a9f24ff8a44577745d59">pt_uint64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a9c2885b0dd3095de04714bf6d791ed61">pt_float</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a840b02ba715ef3b798d3f1b6cb1dd1bc">pt_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899afaa2282a22514a0934a3571b4e4cc75d">pt_long_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a93531ba3275cbc0a4cfcb23a6bbe080e">pt_u8string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ab2a366dcc7a5b7ee1162fd024d6f722e">pt_u16string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac04250078e159cbbb285ad3a39aae4ce">pt_u32string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a8b7d0c7bdeab0ac7b90d756827b95cb4">pt_atom</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a494ed640f1e094e7db23a9ce2f3f199b">pt_null</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga4405c08180f3db0936dcc6afe84f2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>.  <a href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">More...</a><br/></td></tr>
<tr class="separator:ga4405c08180f3db0936dcc6afe84f2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816c542cfd937e5e9da9c9b88304c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>resume_result</b> { <br/>
&#160;&#160;<b>actor_blocked</b>, 
<br/>
&#160;&#160;<b>actor_done</b>
<br/>
 }</td></tr>
<tr class="separator:af816c542cfd937e5e9da9c9b88304c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170d2d86c130ef4375778aa90aec596"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_type</b> { <br/>
&#160;&#160;<b>context_switching_impl</b>, 
<br/>
&#160;&#160;<b>event_based_impl</b>, 
<br/>
&#160;&#160;<b>default_event_based_impl</b>
<br/>
 }</td></tr>
<tr class="separator:a5170d2d86c130ef4375778aa90aec596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab63f2274711ea5cce959c91d793b25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> { <br/>
&#160;&#160;<b>nil</b>, 
<br/>
&#160;&#160;<b>trailing</b>, 
<br/>
&#160;&#160;<b>leading</b>, 
<br/>
&#160;&#160;<b>in_between</b>, 
<br/>
&#160;&#160;<b>multiple</b>
<br/>
 }</td></tr>
<tr class="memdesc:a5ab63f2274711ea5cce959c91d793b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the position of <a class="el" href="structcppa_1_1anything.html">anything</a> in a template parameter pack. <br/></td></tr>
<tr class="separator:a5ab63f2274711ea5cce959c91d793b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40beebfb988f17b8698c209906b13667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40beebfb988f17b8698c209906b13667"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;, const self_type &amp;)</td></tr>
<tr class="separator:a40beebfb988f17b8698c209906b13667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2bbc491f12a4e7817a6c297fd3a836"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2bbc491f12a4e7817a6c297fd3a836"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const self_type &amp;, const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;)</td></tr>
<tr class="separator:ade2bbc491f12a4e7817a6c297fd3a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">announce</a> (const std::type_info &amp;tinfo, std::unique_ptr&lt; <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &gt; utype)</td></tr>
<tr class="memdesc:ga5168c92d6bb51d74f61cea1253940cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping to the libcppa type system.  <a href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">More...</a><br/></td></tr>
<tr class="separator:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">compound_member</a> (C Parent::*c_ptr, const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf92877da942d1a0f1944990cd3d67f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member <code>C</code>.  <a href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">More...</a><br/></td></tr>
<tr class="separator:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">compound_member</a> (C &amp;(Parent::*getter)(), const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf1400abaf4c109b60eba1f83d417b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference.  <a href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">More...</a><br/></td></tr>
<tr class="separator:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplParams" colspan="2">template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Ts&gt; </td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak"/>
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak"/>
, <a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; GRes &gt;<br class="typebreak"/>
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga8f1d70c1c395b02cf3b668fbe103a593">compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;gspair, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter/setter pair.  <a href="group___type_system.html#ga8f1d70c1c395b02cf3b668fbe103a593">More...</a><br/></td></tr>
<tr class="separator:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga855b3b9aeeb091f8f7db15fb0e012fb8">announce</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>T</code> to the libcppa type system.  <a href="group___type_system.html#ga855b3b9aeeb091f8f7db15fb0e012fb8">More...</a><br/></td></tr>
<tr class="separator:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2534a2a021d60eaa4519e36714d435af"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga2534a2a021d60eaa4519e36714d435af">announce_tuple</a> ()</td></tr>
<tr class="memdesc:ga2534a2a021d60eaa4519e36714d435af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a hint to the type system of libcppa. This type hint can significantly increase the network performance, because libcppa can use the hint to create tuples with full static type information rather than using fully dynamically typed tuples. <br/></td></tr>
<tr class="separator:ga2534a2a021d60eaa4519e36714d435af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a28cd5b37281764af3f24ba8ca297c2f3">make_any_tuple</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a28cd5b37281764af3f24ba8ca297c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>.  <a href="#a28cd5b37281764af3f24ba8ca297c2f3">More...</a><br/></td></tr>
<tr class="separator:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> (const <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> &amp;what)</td></tr>
<tr class="memdesc:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>what</code> as a string representation.  <a href="#a76a9f2873d0e97eb7ceffb6101e8e507">More...</a><br/></td></tr>
<tr class="separator:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplParams" colspan="2">template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47">atom</a> (char const (&amp;str)[Size])</td></tr>
<tr class="memdesc:a9ed5b5aa07c384b14899beae80974d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom from given string literal.  <a href="#a9ed5b5aa07c384b14899beae80974d47">More...</a><br/></td></tr>
<tr class="separator:a9ed5b5aa07c384b14899beae80974d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b4784ba07763f01be809c40be5337d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14b4784ba07763f01be809c40be5337d"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a14b4784ba07763f01be809c40be5337d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a14b4784ba07763f01be809c40be5337d">create_unique</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a14b4784ba07763f01be809c40be5337d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative for the 'missing' <code>std::make_unqiue</code>. <br/></td></tr>
<tr class="separator:a14b4784ba07763f01be809c40be5337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f35f5fe58e287026a0149f341e8e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f35f5fe58e287026a0149f341e8e3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> (native_socket_type fd)</td></tr>
<tr class="separator:a41f35f5fe58e287026a0149f341e8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185090573ffb146384ccdfa94172c23e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a185090573ffb146384ccdfa94172c23e">await_all_others_done</a> ()</td></tr>
<tr class="memdesc:a185090573ffb146384ccdfa94172c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks execution of this actor until all other actors finished execution.  <a href="#a185090573ffb146384ccdfa94172c23e">More...</a><br/></td></tr>
<tr class="separator:a185090573ffb146384ccdfa94172c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487e6c08f5f4f7de4775418547f7e93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a487e6c08f5f4f7de4775418547f7e93e">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:a487e6c08f5f4f7de4775418547f7e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> at <code>port</code>.  <a href="#a487e6c08f5f4f7de4775418547f7e93e">More...</a><br/></td></tr>
<tr class="separator:a487e6c08f5f4f7de4775418547f7e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7de4c76a41489b5391c1b9cd24b2e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa7de4c76a41489b5391c1b9cd24b2e1b">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::unique_ptr&lt; <a class="el" href="classcppa_1_1io_1_1acceptor.html">io::acceptor</a> &gt; acceptor)</td></tr>
<tr class="memdesc:aa7de4c76a41489b5391c1b9cd24b2e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections.  <a href="#aa7de4c76a41489b5391c1b9cd24b2e1b">More...</a><br/></td></tr>
<tr class="separator:aa7de4c76a41489b5391c1b9cd24b2e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76739f7f372b92999ee9b80d332093bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76739f7f372b92999ee9b80d332093bd">remote_actor</a> (const char *host, std::uint16_t port)</td></tr>
<tr class="memdesc:a76739f7f372b92999ee9b80d332093bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a76739f7f372b92999ee9b80d332093bd">More...</a><br/></td></tr>
<tr class="separator:a76739f7f372b92999ee9b80d332093bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1e44ab5ef88ac98dd909f3a09bbf181d">remote_actor</a> (const std::string &amp;host, std::uint16_t port)</td></tr>
<tr class="memdesc:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a1e44ab5ef88ac98dd909f3a09bbf181d">More...</a><br/></td></tr>
<tr class="separator:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba6593cce62eab364a52c5a9a7bb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab3ba6593cce62eab364a52c5a9a7bb27">remote_actor</a> (io::stream_ptr_pair connection)</td></tr>
<tr class="memdesc:ab3ba6593cce62eab364a52c5a9a7bb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor via given <code>connection</code>.  <a href="#ab3ba6593cce62eab364a52c5a9a7bb27">More...</a><br/></td></tr>
<tr class="separator:ab3ba6593cce62eab364a52c5a9a7bb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a8a85be51fbecff49379ecaeacca1"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:a187a8a85be51fbecff49379ecaeacca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a187a8a85be51fbecff49379ecaeacca1">spawn_io</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">io::input_stream_ptr</a> in, <a class="el" href="classcppa_1_1intrusive__ptr.html">io::output_stream_ptr</a> out, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a187a8a85be51fbecff49379ecaeacca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an IO actor of type <code>Impl</code>.  <a href="#a187a8a85be51fbecff49379ecaeacca1">More...</a><br/></td></tr>
<tr class="separator:a187a8a85be51fbecff49379ecaeacca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf2717df3f8bf104c6910e26f30833a"><td class="memTemplParams" colspan="2">template&lt;spawn_options Options = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:a9cf2717df3f8bf104c6910e26f30833a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9cf2717df3f8bf104c6910e26f30833a">spawn_io</a> (F fun, <a class="el" href="classcppa_1_1intrusive__ptr.html">io::input_stream_ptr</a> in, <a class="el" href="classcppa_1_1intrusive__ptr.html">io::output_stream_ptr</a> out, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9cf2717df3f8bf104c6910e26f30833a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new <a class="el" href="classcppa_1_1actor.html">actor</a> that evaluates given arguments.  <a href="#a9cf2717df3f8bf104c6910e26f30833a">More...</a><br/></td></tr>
<tr class="separator:a9cf2717df3f8bf104c6910e26f30833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276e46019439975408f1dc2558a43d7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a276e46019439975408f1dc2558a43d7d"></a>
template&lt;spawn_options Options = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:a276e46019439975408f1dc2558a43d7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_io</b> (F fun, const std::string &amp;host, uint16_t port, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a276e46019439975408f1dc2558a43d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17ff3345c5425bbc2ff524310fb6ff0"><td class="memTemplParams" colspan="2"><a class="anchor" id="af17ff3345c5425bbc2ff524310fb6ff0"></a>
template&lt;spawn_options Options = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:af17ff3345c5425bbc2ff524310fb6ff0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_io_server</b> (F fun, uint16_t port, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:af17ff3345c5425bbc2ff524310fb6ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5daac288a10cc34286f505ea637571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5daac288a10cc34286f505ea637571"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8d5daac288a10cc34286f505ea637571">shutdown</a> ()</td></tr>
<tr class="memdesc:a8d5daac288a10cc34286f505ea637571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all singletons, disconnects all peers and stops the scheduler. It is recommended to use this function as very last function call before leaving main(). Especially in programs using libcppa's networking infrastructure. <br/></td></tr>
<tr class="separator:a8d5daac288a10cc34286f505ea637571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d3c95b12475508947918017ead6fac"><td class="memTemplParams" colspan="2"><a class="anchor" id="a32d3c95b12475508947918017ead6fac"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a32d3c95b12475508947918017ead6fac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; !is_behavior_policy<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; T &gt;<br class="typebreak"/>
::type &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a32d3c95b12475508947918017ead6fac">become</a> (T &amp;&amp;arg, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a32d3c95b12475508947918017ead6fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor's behavior and discards the previous behavior unless <a class="el" href="">keep_behavior</a> is given as first argument. <br/></td></tr>
<tr class="separator:a32d3c95b12475508947918017ead6fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb78c2b86b38c9deb5db6f37012d94e9"></a>
template&lt;bool Discard, typename... Ts&gt; </td></tr>
<tr class="memitem:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>become</b> (behavior_policy&lt; Discard &gt;, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bfd1a9574057e1470ea7d26167ba18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1bfd1a9574057e1470ea7d26167ba18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae1bfd1a9574057e1470ea7d26167ba18">unbecome</a> ()</td></tr>
<tr class="memdesc:ae1bfd1a9574057e1470ea7d26167ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns to a previous behavior if available. <br/></td></tr>
<tr class="separator:ae1bfd1a9574057e1470ea7d26167ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08349cb93c162f2d9cfd274ae53e6b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08349cb93c162f2d9cfd274ae53e6b3"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, std::string arg)</td></tr>
<tr class="separator:ae08349cb93c162f2d9cfd274ae53e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58f34b5d1df5cb163efe061d8465787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab58f34b5d1df5cb163efe061d8465787"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;arg)</td></tr>
<tr class="separator:ab58f34b5d1df5cb163efe061d8465787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e73779295076dcc0c2439cc6429e80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68e73779295076dcc0c2439cc6429e80"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, const char *arg)</td></tr>
<tr class="separator:a68e73779295076dcc0c2439cc6429e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb22f11ff2b313255451216e4c70fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3feb22f11ff2b313255451216e4c70fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3feb22f11ff2b313255451216e4c70fc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; !std::is_convertible&lt; T, <br class="typebreak"/>
std::string &gt;::value <br class="typebreak"/>
&amp;&amp;!std::is_convertible&lt; T, <br class="typebreak"/>
<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &gt;::value, const <br class="typebreak"/>
actor_ostream &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, T &amp;&amp;arg)</td></tr>
<tr class="separator:a3feb22f11ff2b313255451216e4c70fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca5dce51a19e691510357f726bcb3e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca5dce51a19e691510357f726bcb3e5"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, actor_ostream::fun_type f)</td></tr>
<tr class="separator:a3ca5dce51a19e691510357f726bcb3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aaa221547ef879ba5b42f7cc7820f90e1">from_string</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:aaa221547ef879ba5b42f7cc7820f90e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value.  <a href="#aaa221547ef879ba5b42f7cc7820f90e1">More...</a><br/></td></tr>
<tr class="separator:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21ab9e2f184e710548682e60d194053"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab21ab9e2f184e710548682e60d194053"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ab21ab9e2f184e710548682e60d194053"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:ab21ab9e2f184e710548682e60d194053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a529b5f85f7a7b0899f0fbb9b3bbf11f5"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f6f2665d3e0bece6ab055d20cf30e4c"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e7fa77d8ef1b9e193ea4c36851c1df3"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554705905154ae92cdb3e31280a17554"><td class="memTemplParams" colspan="2"><a class="anchor" id="a554705905154ae92cdb3e31280a17554"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a554705905154ae92cdb3e31280a17554"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a554705905154ae92cdb3e31280a17554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107053e5101889fb6707b24b792f1b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa107053e5101889fb6707b24b792f1b5"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa107053e5101889fb6707b24b792f1b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:aa107053e5101889fb6707b24b792f1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa82f5eafdc520298a1fcf0848d5c42b7"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3b50642f923d63806735ee22b9f2be8"></a>
template&lt;size_t Pos, typename... Ts&gt; </td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (std::tuple&lt; Ts...&gt; &amp;tup) -&gt; decltype(std::get&lt; Pos &gt;(tup))</td></tr>
<tr class="separator:ab3b50642f923d63806735ee22b9f2be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c26044ba1f8a78aa4d43cd13e2a9abe"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7c26044ba1f8a78aa4d43cd13e2a9abe">get_cv_aware</a> (Tuple &amp;tup) -&gt; decltype(get_ref&lt; Pos &gt;(tup))</td></tr>
<tr class="memdesc:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c6a41ff1aa0eefc3e1413cda6519dd1"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a0c6a41ff1aa0eefc3e1413cda6519dd1">get_cv_aware</a> (const Tuple &amp;tup) -&gt; decltype(get&lt; Pos &gt;(tup))</td></tr>
<tr class="memdesc:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213a56201820111919afe92aa287586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae213a56201820111919afe92aa287586">publish_local_groups_at</a> (std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:ae213a56201820111919afe92aa287586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>.  <a href="#ae213a56201820111919afe92aa287586">More...</a><br/></td></tr>
<tr class="separator:ae213a56201820111919afe92aa287586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17ab2c74affc2496609bacf3be1f46de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a><br class="typebreak"/>
&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a17ab2c74affc2496609bacf3be1f46de">gref</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a17ab2c74affc2496609bacf3be1f46de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper similar to std::reference_wrapper&lt;const T&gt; that could be used in guard expressions or to enforce lazy evaluation. <br/></td></tr>
<tr class="separator:a17ab2c74affc2496609bacf3be1f46de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef395eaa7bd389ba17e28867010b5a7e"></a>
template&lt;typename Fun , typename T1 &gt; </td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplItemLeft" align="right" valign="top">gcall1&lt; Fun, T1 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aef395eaa7bd389ba17e28867010b5a7e">gcall</a> (Fun fun, T1 t1)</td></tr>
<tr class="memdesc:aef395eaa7bd389ba17e28867010b5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:aef395eaa7bd389ba17e28867010b5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a444ff11a730b8c1d42d5499c8fd36ed0"></a>
template&lt;typename Fun , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplItemLeft" align="right" valign="top">gcall2&lt; Fun, T1, T2 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a444ff11a730b8c1d42d5499c8fd36ed0">gcall</a> (Fun fun, T1 t1, T2 t2)</td></tr>
<tr class="memdesc:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb38db3897563dd010b0159b7598ce24"></a>
template&lt;typename Fun , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplItemLeft" align="right" valign="top">gcall3&lt; Fun, T1, T2, T3 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afb38db3897563dd010b0159b7598ce24">gcall</a> (Fun fun, T1 t1, T2 t2, T3 t3)</td></tr>
<tr class="memdesc:afb38db3897563dd010b0159b7598ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:afb38db3897563dd010b0159b7598ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0966a88da87efe71b9d16a95cfee6bb4"></a>
template&lt;typename Fun &gt; </td></tr>
<tr class="memitem:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; exec_xfun_op, Fun, <br class="typebreak"/>
unit_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a0966a88da87efe71b9d16a95cfee6bb4">ge_sub_function</a> (Fun fun)</td></tr>
<tr class="memdesc:a0966a88da87efe71b9d16a95cfee6bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>fun</code> with all arguments given to the guard expression. The functor <code>fun</code> must return a boolean. <br/></td></tr>
<tr class="separator:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplParams" colspan="2"><a class="anchor" id="a832d63b8b90c03075666e5b709805222"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplItemLeft" align="right" valign="top">ge_value&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gval</b> (T <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>)</td></tr>
<tr class="separator:a832d63b8b90c03075666e5b709805222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee6efd772c183821806213315e16c30c"></a>
template&lt;operator_id OP, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; OP, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T2 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_concatenate</b> (T1 first, T2 second, typename std::enable_if&lt; is_ge_type&lt; T1 &gt;::value||is_ge_type&lt; T2 &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:aee6efd772c183821806213315e16c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55ae21ec736d7c79de5bc814efab66ca"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_and_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a55ae21ec736d7c79de5bc814efab66ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a628c9ea9c68a69a765e1c22ebab625b9"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_or_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3df0ac35ccc8aca49cfd042f977a375b"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const T &amp;value)</td></tr>
<tr class="separator:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44077174990342ce322b5c720af285a7"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; T &gt; &amp;value)</td></tr>
<tr class="separator:a44077174990342ce322b5c720af285a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f4027bf874a6ff4ad23d688ffe08544"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2dea78fc9947ec1611c055242acad42"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const <a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a>&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:af2dea78fc9947ec1611c055242acad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace2410091863897048954dde384e70df"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const ge_value&lt; T &gt; &amp;wrapped_value)</td></tr>
<tr class="separator:ace2410091863897048954dde384e70df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89265fd784a63cdd2d9143c74e6f2f94"></a>
template&lt;class Tuple , int X&gt; </td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, <a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a>&lt; X &gt;) -&gt; decltype(get&lt; X &gt;(tup).get())</td></tr>
<tr class="separator:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83b5290d7cca52854f219727919d56d5"></a>
template&lt;class Tuple , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, const guard_expr&lt; OP, First, Second &gt; &amp;ge) -&gt; typename ge_result&lt; OP, First, Second, Tuple &gt;::type</td></tr>
<tr class="separator:a83b5290d7cca52854f219727919d56d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c3c9b3d2cf91e86fbefa608b71b6ed1"></a>
template&lt;operator_id OP, class Tuple , typename First , typename Second &gt; </td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
Tuple &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_eval</b> (const Tuple &amp;tup, const First &amp;lhs, const Second &amp;rhs)</td></tr>
<tr class="separator:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93f59e94232ea05ac9753812211e33f1"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_step2</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const detail::tdata&lt; Ts...&gt; &amp;tup) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; Ts...&gt;&gt;::type</td></tr>
<tr class="separator:a93f59e94232ea05ac9753812211e33f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a439d948767945bc2fccd61fe7bb31d44"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const Ts &amp;...args) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; std::reference_wrapper&lt; const Ts &gt;...&gt;&gt;::type</td></tr>
<tr class="separator:a439d948767945bc2fccd61fe7bb31d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2a82a93906c827b7ada3f6ffe195a56"></a>
template&lt;typename TupleTypes , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
typename <br class="typebreak"/>
detail::tdata_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__filter__not.html">util::tl_filter_not</a><br class="typebreak"/>
&lt; TupleTypes, <a class="el" href="structcppa_1_1is__anything.html">is_anything</a> &gt;<br class="typebreak"/>
::type &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_any</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;tup)</td></tr>
<tr class="separator:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec9247a4f2fd10333c67831d57d6355"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ec9247a4f2fd10333c67831d57d6355"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a7ec9247a4f2fd10333c67831d57d6355"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7ec9247a4f2fd10333c67831d57d6355">make_counted</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7ec9247a4f2fd10333c67831d57d6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T which must be a derived type of <a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a> and wraps it in an <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>. <br/></td></tr>
<tr class="separator:a7ec9247a4f2fd10333c67831d57d6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f244ace12cc81405ba240e2e3273c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1f244ace12cc81405ba240e2e3273c7"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aa1f244ace12cc81405ba240e2e3273c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; not <br class="typebreak"/>
is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_counted</b> (Ts &amp;&amp;...args)</td></tr>
<tr class="separator:aa1f244ace12cc81405ba240e2e3273c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db87bb3f005546ffb41a164653788ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3db87bb3f005546ffb41a164653788ae"></a>
<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fwd_aptr</b> (const self_type &amp;s)</td></tr>
<tr class="separator:a3db87bb3f005546ffb41a164653788ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c216cb49f17a377f29486581861f27d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c216cb49f17a377f29486581861f27d"></a>
<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fwd_aptr</b> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> ptr)</td></tr>
<tr class="separator:a8c216cb49f17a377f29486581861f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef26aeefd5299203995aa3733d25525b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef26aeefd5299203995aa3733d25525b"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, std::string str)</td></tr>
<tr class="separator:aef26aeefd5299203995aa3733d25525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717c7a06002e2d309d76eaf5c05a4f28"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, const char *str)</td></tr>
<tr class="separator:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56abb51f6a9aec9ed8d1abb736adc064"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplItemLeft" align="right" valign="top">oss_wr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, T rhs)</td></tr>
<tr class="separator:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65859efc090932630d14b226b9c9624"><td class="memItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad65859efc090932630d14b226b9c9624">match</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ad65859efc090932630d14b226b9c9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#ad65859efc090932630d14b226b9c9624">More...</a><br/></td></tr>
<tr class="separator:ad65859efc090932630d14b226b9c9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#adaa18a8117e9022caea2b0606c11ebbc">match</a> (T &amp;&amp;what)</td></tr>
<tr class="memdesc:adaa18a8117e9022caea2b0606c11ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#adaa18a8117e9022caea2b0606c11ebbc">More...</a><br/></td></tr>
<tr class="separator:adaa18a8117e9022caea2b0606c11ebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c996a6bbaef4f7127218b5513226f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a512c996a6bbaef4f7127218b5513226f"></a>
detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a512c996a6bbaef4f7127218b5513226f">match_split</a> (const std::string &amp;str, char delim, bool keep_empties=false)</td></tr>
<tr class="memdesc:a512c996a6bbaef4f7127218b5513226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> using <code>delim</code> and match the resulting strings. <br/></td></tr>
<tr class="separator:a512c996a6bbaef4f7127218b5513226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ca31369f494fd492be6de8bec9d96d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a63ca31369f494fd492be6de8bec9d96d"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak"/>
&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a63ca31369f494fd492be6de8bec9d96d">match_each</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a63ca31369f494fd492be6de8bec9d96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches each element in range [first, last).  <a href="#a63ca31369f494fd492be6de8bec9d96d">More...</a><br/></td></tr>
<tr class="separator:a63ca31369f494fd492be6de8bec9d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b5c639c9579b617662e3de649ed0cb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Projection &gt; </td></tr>
<tr class="memitem:a35b5c639c9579b617662e3de649ed0cb"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak"/>
&lt; InputIterator, Projection &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a35b5c639c9579b617662e3de649ed0cb">match_each</a> (InputIterator first, InputIterator last, Projection proj)</td></tr>
<tr class="memdesc:a35b5c639c9579b617662e3de649ed0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last).  <a href="#a35b5c639c9579b617662e3de649ed0cb">More...</a><br/></td></tr>
<tr class="separator:a35b5c639c9579b617662e3de649ed0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5bf86134d84a11926891e241b2f209"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b5bf86134d84a11926891e241b2f209"></a>
template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a6b5bf86134d84a11926891e241b2f209"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred)</td></tr>
<tr class="separator:a6b5bf86134d84a11926891e241b2f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2514e5f45663a8c671d73f6073372b77"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2514e5f45663a8c671d73f6073372b77"></a>
template&lt;typename InputIterator , typename Predicate , typename Advance &gt; </td></tr>
<tr class="memitem:a2514e5f45663a8c671d73f6073372b77"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate, <br class="typebreak"/>
Advance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv)</td></tr>
<tr class="separator:a2514e5f45663a8c671d73f6073372b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31979b2bf7c1ce503faf43dbed6f210b"></a>
template&lt;class InputIterator , class Predicate , class Advance , class Projection &gt; </td></tr>
<tr class="memitem:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate, <br class="typebreak"/>
Advance, Projection &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv, Projection pj)</td></tr>
<tr class="separator:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e1f7de88c500126cd7626401724d10b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
std::istream_iterator&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (std::istream &amp;stream)</td></tr>
<tr class="separator:a9e1f7de88c500126cd7626401724d10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92e87041ae91c323107ec8a2cc269762"></a>
template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a92e87041ae91c323107ec8a2cc269762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa712d31b5091ed057a8127d781ba3b21"></a>
template&lt;typename... Lhs, typename... Rhs&gt; </td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs..., Rhs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs...&gt; &amp;lhs, const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Rhs...&gt; &amp;rhs)</td></tr>
<tr class="separator:aa712d31b5091ed057a8127d781ba3b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a909d6f63fb7e39d1b66679d4585e71eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ceb36fc3f2adc25b284b702d30e14eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;arg)</td></tr>
<tr class="separator:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28515cdabde2f2a8d4cb6d342fb68477"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f17df0c43239b3ad2c7aa794ff1616c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplItemLeft" align="right" valign="top">match_expr_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__concat.html">util::tl_concat</a><br class="typebreak"/>
&lt; typename T::cases_list, <br class="typebreak"/>
typename Ts::cases_list... &gt;<br class="typebreak"/>
::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="separator:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793aa6f7a6e38d7a48671b29918bac9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793aa6f7a6e38d7a48671b29918bac9e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="namespacecppa.html#a648afc4427bb8aa7b883b1940ca761ba">match_hint</a>)</td></tr>
<tr class="separator:a793aa6f7a6e38d7a48671b29918bac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15c62d1f2083756252c0fafef92f900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15c62d1f2083756252c0fafef92f900"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;rhs)</td></tr>
<tr class="separator:ad15c62d1f2083756252c0fafef92f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529d4d702ab15d36e5181ae7d6be478d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a529d4d702ab15d36e5181ae7d6be478d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;rhs)</td></tr>
<tr class="separator:a529d4d702ab15d36e5181ae7d6be478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e103f83664c764b44799700daa1e83e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e103f83664c764b44799700daa1e83e"></a>
const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_typeid</b> (const std::type_info &amp;)</td></tr>
<tr class="separator:a9e103f83664c764b44799700daa1e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d771014d43e74ef4e17073bebaa2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &amp;lhs, const std::type_info &amp;rhs)</td></tr>
<tr class="separator:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfef6633740c1eff30d983dcfba54f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeccfef6633740c1eff30d983dcfba54f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;lhs, const <a class="el" href="classcppa_1_1object.html">object</a> &amp;rhs)</td></tr>
<tr class="separator:aeccfef6633740c1eff30d983dcfba54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc4d0a97a3d502f72511ea3464db9e13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:afc4d0a97a3d502f72511ea3464db9e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafac7c509fc9734cffbf3608e64a04b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:aafac7c509fc9734cffbf3608e64a04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44555735faa3d6357ad58b59e92c38c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44555735faa3d6357ad58b59e92c38c0"></a>
<a class="el" href="namespacecppa.html#a648afc4427bb8aa7b883b1940ca761ba">match_hint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a44555735faa3d6357ad58b59e92c38c0">skip_message</a> ()</td></tr>
<tr class="memdesc:a44555735faa3d6357ad58b59e92c38c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="namespacecppa.html#a648afc4427bb8aa7b883b1940ca761ba">skipped</a>. <br/></td></tr>
<tr class="separator:a44555735faa3d6357ad58b59e92c38c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a> ()</td></tr>
<tr class="memdesc:af928936d573122345bc0737615f95f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any value of type <code>T</code>.  <a href="#af928936d573122345bc0737615f95f33">More...</a><br/></td></tr>
<tr class="separator:af928936d573122345bc0737615f95f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on</a> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="memdesc:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches values.  <a href="#a25d0d9e15f20fe8a0644a1d137d27e90">More...</a><br/></td></tr>
<tr class="separator:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#acb8c5c063a1758690748e20c805a76aa">on</a> ()</td></tr>
<tr class="memdesc:acb8c5c063a1758690748e20c805a76aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#acb8c5c063a1758690748e20c805a76aa">More...</a><br/></td></tr>
<tr class="separator:acb8c5c063a1758690748e20c805a76aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplParams" colspan="2">template&lt;atom_value... Atoms, typename... Ts&gt; </td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1341cd8bd16f4821146053de1093a732">on</a> ()</td></tr>
<tr class="memdesc:a1341cd8bd16f4821146053de1093a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#a1341cd8bd16f4821146053de1093a732">More...</a><br/></td></tr>
<tr class="separator:a1341cd8bd16f4821146053de1093a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5874085dfe88492adbc380b55c77053f"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:a5874085dfe88492adbc380b55c77053f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5874085dfe88492adbc380b55c77053f">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a5874085dfe88492adbc380b55c77053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>.  <a href="#a5874085dfe88492adbc380b55c77053f">More...</a><br/></td></tr>
<tr class="separator:a5874085dfe88492adbc380b55c77053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733d5a4394026abf6ddaba265f6970e8"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:a733d5a4394026abf6ddaba265f6970e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a733d5a4394026abf6ddaba265f6970e8">spawn_cl</a> (const char *source, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a733d5a4394026abf6ddaba265f6970e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>.  <a href="#a733d5a4394026abf6ddaba265f6970e8">More...</a><br/></td></tr>
<tr class="separator:a733d5a4394026abf6ddaba265f6970e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7d7ec2cc77f30d3921a26fa21b902075">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a7d7ec2cc77f30d3921a26fa21b902075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#a7d7ec2cc77f30d3921a26fa21b902075">More...</a><br/></td></tr>
<tr class="separator:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91e347999ca21eaf734024e45eff768"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:ae91e347999ca21eaf734024e45eff768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae91e347999ca21eaf734024e45eff768">spawn_cl</a> (const char *source, const char *fun_name, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:ae91e347999ca21eaf734024e45eff768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#ae91e347999ca21eaf734024e45eff768">More...</a><br/></td></tr>
<tr class="separator:ae91e347999ca21eaf734024e45eff768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a203490e67e091f123d0cc6f7884e88c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplItemLeft" align="right" valign="top">detail::rd_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a203490e67e091f123d0cc6f7884e88c9">rd_arg</a> (T &amp;storage)</td></tr>
<tr class="memdesc:a203490e67e091f123d0cc6f7884e88c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option reading an argument of type <code>T</code>. <br/></td></tr>
<tr class="separator:a203490e67e091f123d0cc6f7884e88c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1ebc36e2bddc5cef48f1688af4d7608"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplItemLeft" align="right" valign="top">detail::add_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab1ebc36e2bddc5cef48f1688af4d7608">add_arg</a> (std::vector&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option adding an argument of type <code>T</code> to <code>storage</code>. <br/></td></tr>
<tr class="separator:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccdbd7a582b0e63258548e836f00c9a"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_flag</b> (bool &amp;storage)</td></tr>
<tr class="separator:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e2e610b7d676a86b43b7b5552ea3e9"></a>
detail::opt1_rvalue_builder&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac6e2e610b7d676a86b43b7b5552ea3e9">on_opt1</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with one argument. <br/></td></tr>
<tr class="separator:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bbb3d478cab709c2eeae7146d73f24c"></a>
detail::opt0_rvalue_builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5bbb3d478cab709c2eeae7146d73f24c">on_opt0</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:a5bbb3d478cab709c2eeae7146d73f24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with no argument. <br/></td></tr>
<tr class="separator:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e9f8e43fb78f1a6c9afb6700ebe4404"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e9f8e43fb78f1a6c9afb6700ebe4404">print_desc</a> (<a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code>. <br/></td></tr>
<tr class="separator:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2216fa186264747a6256d0d21dbf98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2216fa186264747a6256d0d21dbf98"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aeb2216fa186264747a6256d0d21dbf98">print_desc_and_exit</a> (<a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc, std::ostream &amp;out=std::cout, int exit_reason=0)</td></tr>
<tr class="memdesc:aeb2216fa186264747a6256d0d21dbf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code> and then calls <code>exit(exit_reason)</code>. <br/></td></tr>
<tr class="separator:aeb2216fa186264747a6256d0d21dbf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98654521009995df429c7cee6444d415"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98654521009995df429c7cee6444d415"></a>
template&lt;int Value&gt; </td></tr>
<tr class="memitem:a98654521009995df429c7cee6444d415"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak"/>
std::integral_constant&lt; int, <br class="typebreak"/>
Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_int_token</b> ()</td></tr>
<tr class="separator:a98654521009995df429c7cee6444d415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5528c744a5047da483f0f67738fce5f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5528c744a5047da483f0f67738fce5f9"></a>
template&lt;bool Value&gt; </td></tr>
<tr class="memitem:a5528c744a5047da483f0f67738fce5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak"/>
std::integral_constant&lt; bool, <br class="typebreak"/>
Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_bool_token</b> ()</td></tr>
<tr class="separator:a5528c744a5047da483f0f67738fce5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a8c724382cad6efe2ddc779e931f5c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6a8c724382cad6efe2ddc779e931f5c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:af6a8c724382cad6efe2ddc779e931f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; T, typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; Ts &gt;<br class="typebreak"/>
::type...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional_variant</b> (T value, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:af6a8c724382cad6efe2ddc779e931f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab6cd987f3ecf6cea41ec75786e51b3d8"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional_variant</b> (<a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; Ts...&gt; value)</td></tr>
<tr class="separator:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f61c795312530eae5131497506a7994"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f61c795312530eae5131497506a7994"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f61c795312530eae5131497506a7994"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak"/>
&lt; T::may_have_timeout, <br class="typebreak"/>
<a class="el" href="classcppa_1_1behavior.html">behavior</a>, <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_convert</b> (const T &amp;arg)</td></tr>
<tr class="separator:a5f61c795312530eae5131497506a7994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0346c0284061a4c26dd488dc0bf1fc1f"></a>
template&lt;typename T0 , typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak"/>
&lt; <a class="el" href="structcppa_1_1util_1_1disjunction.html">util::disjunction</a><br class="typebreak"/>
&lt; T0::may_have_timeout, <br class="typebreak"/>
T1::may_have_timeout, <br class="typebreak"/>
Ts::may_have_timeout... &gt;<br class="typebreak"/>
::value, <a class="el" href="classcppa_1_1behavior.html">behavior</a>, <br class="typebreak"/>
<a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_convert</b> (const T0 &amp;arg0, const T1 &amp;arg1, const Ts &amp;...args)</td></tr>
<tr class="separator:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608cce08de994ecd153215923e176bd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a608cce08de994ecd153215923e176bd4"></a>
template&lt;typename... Cases&gt; </td></tr>
<tr class="memitem:a608cce08de994ecd153215923e176bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cases...&gt; &amp;mexpr, const <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &amp;pfun)</td></tr>
<tr class="separator:a608cce08de994ecd153215923e176bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">primitive_type_name</a> (<a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> ptype)</td></tr>
<tr class="memdesc:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899" title="Represents the type flag of primitive_variant. ">primitive_type</a> value to its name.  <a href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">More...</a><br/></td></tr>
<tr class="separator:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f48cc1f5e2597c4a131d292145f728f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:a1f48cc1f5e2597c4a131d292145f728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7eeed8ed3edc2558cf01f26bf86691"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad36edc791ad88439e6b1d30e9ea14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00ad36edc791ad88439e6b1d30e9ea14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>node_id_from_string</b> (const std::string &amp;hash, <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="separator:a00ad36edc791ad88439e6b1d30e9ea14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da650abe0612dd640f67af532373440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da650abe0612dd640f67af532373440"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const std::string &amp;hash, const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="separator:a6da650abe0612dd640f67af532373440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadf880997152157b01eb708534fe09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fadf880997152157b01eb708534fe09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id, const std::string &amp;hash)</td></tr>
<tr class="separator:a9fadf880997152157b01eb708534fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b764d3d88909554ba09e0b7942ac1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0b764d3d88909554ba09e0b7942ac1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>receive_loop</b> (<a class="el" href="classcppa_1_1behavior.html">behavior</a> rules)</td></tr>
<tr class="separator:af0b764d3d88909554ba09e0b7942ac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9fd959a7ff3c017ded6b64ee72dcec97">set_scheduler</a> (<a class="el" href="classcppa_1_1scheduler.html">scheduler</a> *sched)</td></tr>
<tr class="memdesc:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scheduler to <code>sched</code>.  <a href="#a9fd959a7ff3c017ded6b64ee72dcec97">More...</a><br/></td></tr>
<tr class="separator:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a11054c90870f7f7bae3117845127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8f2a11054c90870f7f7bae3117845127">set_default_scheduler</a> (size_t num_threads)</td></tr>
<tr class="memdesc:a8f2a11054c90870f7f7bae3117845127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a thread pool scheduler with <code>num_threads</code> worker threads.  <a href="#a8f2a11054c90870f7f7bae3117845127">More...</a><br/></td></tr>
<tr class="separator:a8f2a11054c90870f7f7bae3117845127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090fbee59721028912f07709e6ac8882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a090fbee59721028912f07709e6ac8882"></a>
logging *&#160;</td><td class="memItemRight" valign="bottom"><b>get_logger</b> ()</td></tr>
<tr class="separator:a090fbee59721028912f07709e6ac8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438040c204e8dc7819cd7ca9bd661eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438040c204e8dc7819cd7ca9bd661eec"></a>
<a class="el" href="classcppa_1_1scheduler.html">scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_scheduler</b> ()</td></tr>
<tr class="separator:a438040c204e8dc7819cd7ca9bd661eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7767f4842534d531923125cb8f06d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7767f4842534d531923125cb8f06d9"></a>
detail::group_manager *&#160;</td><td class="memItemRight" valign="bottom"><b>get_group_manager</b> ()</td></tr>
<tr class="separator:a8c7767f4842534d531923125cb8f06d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1761ff3671f8270518ebce7f025db448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1761ff3671f8270518ebce7f025db448"></a>
detail::actor_registry *&#160;</td><td class="memItemRight" valign="bottom"><b>get_actor_registry</b> ()</td></tr>
<tr class="separator:a1761ff3671f8270518ebce7f025db448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3136f786e4a1ff9cd29c1ce18cd0db5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3136f786e4a1ff9cd29c1ce18cd0db5a"></a>
<a class="el" href="classcppa_1_1io_1_1middleman.html">io::middleman</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_middleman</b> ()</td></tr>
<tr class="separator:a3136f786e4a1ff9cd29c1ce18cd0db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb30b478f6a94f90dc672d718160781"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb30b478f6a94f90dc672d718160781"></a>
detail::uniform_type_info_map *&#160;</td><td class="memItemRight" valign="bottom"><b>get_uniform_type_info_map</b> ()</td></tr>
<tr class="separator:a6eb30b478f6a94f90dc672d718160781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef56ad712e7f872723ccf0e992c2095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef56ad712e7f872723ccf0e992c2095"></a>
detail::abstract_tuple *&#160;</td><td class="memItemRight" valign="bottom"><b>get_tuple_dummy</b> ()</td></tr>
<tr class="separator:a9ef56ad712e7f872723ccf0e992c2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3c155b29caab8bf8a461b751eec4be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b3c155b29caab8bf8a461b751eec4be"></a>
detail::empty_tuple *&#160;</td><td class="memItemRight" valign="bottom"><b>get_empty_tuple</b> ()</td></tr>
<tr class="separator:a7b3c155b29caab8bf8a461b751eec4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035b1212d0d0634d4122133381a89c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8035b1212d0d0634d4122133381a89c1"></a>
opencl::opencl_metainfo *&#160;</td><td class="memItemRight" valign="bottom"><b>get_opencl_metainfo</b> ()</td></tr>
<tr class="separator:a8035b1212d0d0634d4122133381a89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a28e93004ce87aa330248e4a5604ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a28e93004ce87aa330248e4a5604ec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;what)</td></tr>
<tr class="separator:a58a28e93004ce87aa330248e4a5604ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55814e02519b1cb77284a869b0dc1ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55814e02519b1cb77284a869b0dc1ac"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;what)</td></tr>
<tr class="separator:ac55814e02519b1cb77284a869b0dc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dafe56a214fb056845a07e3b884ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dafe56a214fb056845a07e3b884ca7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;what)</td></tr>
<tr class="separator:ab5dafe56a214fb056845a07e3b884ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757fb5458e2f5824fb6a0ee1b48092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb757fb5458e2f5824fb6a0ee1b48092"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;what)</td></tr>
<tr class="separator:aeb757fb5458e2f5824fb6a0ee1b48092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e006c238ecdc980569af6c05828772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17e006c238ecdc980569af6c05828772"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;what)</td></tr>
<tr class="separator:a17e006c238ecdc980569af6c05828772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb103c782d4dd432e52f51e247743c3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb103c782d4dd432e52f51e247743c3f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1process__information.html">process_information</a> &amp;what)</td></tr>
<tr class="separator:afb103c782d4dd432e52f51e247743c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c07fee8995c064a3dc80378ba9911df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c07fee8995c064a3dc80378ba9911df"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">process_information_ptr</a> &amp;what)</td></tr>
<tr class="separator:a2c07fee8995c064a3dc80378ba9911df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7919488dad32bd35a6e461f4ae6d0bd7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;what)</td></tr>
<tr class="separator:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aae38fbd2f412089646134bbb5c75f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60aae38fbd2f412089646134bbb5c75f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a60aae38fbd2f412089646134bbb5c75f">to_verbose_string</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a60aae38fbd2f412089646134bbb5c75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>e</code> to a string including the demangled type of e and <code>e.what()</code>. <br/></td></tr>
<tr class="separator:a60aae38fbd2f412089646134bbb5c75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplParams" colspan="2">template&lt;typename Types &gt; </td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33344c46529f70febab48161c0c53a68">get_wildcard_position</a> ()</td></tr>
<tr class="memdesc:a33344c46529f70febab48161c0c53a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>.  <a href="#a33344c46529f70febab48161c0c53a68">More...</a><br/></td></tr>
<tr class="separator:a33344c46529f70febab48161c0c53a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7f3fbaf504c9a1f71935cea14328b95"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memTemplItemLeft" align="right" valign="top">util::tl_at&lt; <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a><br class="typebreak"/>
&lt; Ts...&gt;, N &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae63749d6509704209aa33979db01eadb"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:gae63749d6509704209aa33979db01eadb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecppa.html#a9beaceb1768c40b55c645612aa93daae">enable_if_channel</a>&lt; C, const <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#gae63749d6509704209aa33979db01eadb">operator&lt;&lt;</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp;whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:gae63749d6509704209aa33979db01eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code>.  <a href="group___message_handling.html#gae63749d6509704209aa33979db01eadb">More...</a><br/></td></tr>
<tr class="separator:gae63749d6509704209aa33979db01eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9832d0c878b8e8635c7d5f23220a1b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9832d0c878b8e8635c7d5f23220a1b0f"></a>
const self_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const self_type &amp;s, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="separator:ga9832d0c878b8e8635c7d5f23220a1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga2572278151133dc5aea4ef57f15ba79a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2572278151133dc5aea4ef57f15ba79a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2572278151133dc5aea4ef57f15ba79a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga2572278151133dc5aea4ef57f15ba79a">receive</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga2572278151133dc5aea4ef57f15ba79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues the next message from the mailbox that is matched by given behavior. <br/></td></tr>
<tr class="separator:ga2572278151133dc5aea4ef57f15ba79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dd7ae464477ee09420f3db58803806"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa4dd7ae464477ee09420f3db58803806"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaa4dd7ae464477ee09420f3db58803806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#gaa4dd7ae464477ee09420f3db58803806">receive_loop</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaa4dd7ae464477ee09420f3db58803806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages in an endless loop. Semantically equal to: <code>for (;;) { receive(...); }</code> <br/></td></tr>
<tr class="separator:gaa4dd7ae464477ee09420f3db58803806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memTemplItemLeft" align="right" valign="top">detail::receive_for_helper&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#gac8c02896ff6b0ca3a36829fbe1482584">receive_for</a> (T &amp;begin, const T &amp;end)</td></tr>
<tr class="memdesc:gac8c02896ff6b0ca3a36829fbe1482584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as in a range-based loop.  <a href="group___blocking_a_p_i.html#gac8c02896ff6b0ca3a36829fbe1482584">More...</a><br/></td></tr>
<tr class="separator:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7410ca248936f055cdf10d90694af732"><td class="memTemplParams" colspan="2">template&lt;typename Statement &gt; </td></tr>
<tr class="memitem:ga7410ca248936f055cdf10d90694af732"><td class="memTemplItemLeft" align="right" valign="top">detail::receive_while_helper<br class="typebreak"/>
&lt; Statement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga7410ca248936f055cdf10d90694af732">receive_while</a> (Statement &amp;&amp;stmt)</td></tr>
<tr class="memdesc:ga7410ca248936f055cdf10d90694af732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as long as <code>stmt</code> returns true.  <a href="group___blocking_a_p_i.html#ga7410ca248936f055cdf10d90694af732">More...</a><br/></td></tr>
<tr class="separator:ga7410ca248936f055cdf10d90694af732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memTemplItemLeft" align="right" valign="top">detail::do_receive_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga32a52e24a04a2e4cb0d5de312b94b4c8">do_receive</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages until <code>stmt</code> returns true.  <a href="group___blocking_a_p_i.html#ga32a52e24a04a2e4cb0d5de312b94b4c8">More...</a><br/></td></tr>
<tr class="separator:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memTemplParams" colspan="2">template&lt;spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga64b99980b69ba8e8cdd218e402f48fd6">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new <a class="el" href="classcppa_1_1actor.html">actor</a> that evaluates given arguments.  <a href="group___actor_creation.html#ga64b99980b69ba8e8cdd218e402f48fd6">More...</a><br/></td></tr>
<tr class="separator:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ea633de5e468cacd5156d014b7c647"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gae0ea633de5e468cacd5156d014b7c647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gae0ea633de5e468cacd5156d014b7c647">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gae0ea633de5e468cacd5156d014b7c647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>Impl</code>.  <a href="group___actor_creation.html#gae0ea633de5e468cacd5156d014b7c647">More...</a><br/></td></tr>
<tr class="separator:gae0ea633de5e468cacd5156d014b7c647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memTemplParams" colspan="2">template&lt;spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga72975ef0dee3891fb56c195c0a75fc2b">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new actor that evaluates given arguments and immediately joins <code>grp</code>.  <a href="group___actor_creation.html#ga72975ef0dee3891fb56c195c0a75fc2b">More...</a><br/></td></tr>
<tr class="separator:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Options, typename... Ts&gt; </td></tr>
<tr class="memitem:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gacfc41ffbe46b4e47a4a6955e4fe0c6e3">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>Impl</code> that immediately joins <code>grp</code>.  <a href="group___actor_creation.html#gacfc41ffbe46b4e47a4a6955e4fe0c6e3">More...</a><br/></td></tr>
<tr class="separator:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e85fddea6ef0ab8c90b00a39afb8044"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8e85fddea6ef0ab8c90b00a39afb8044"></a>
template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga8e85fddea6ef0ab8c90b00a39afb8044"><td class="memTemplItemLeft" align="right" valign="top">Impl::typed_pointer_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_typed</b> (Ts &amp;&amp;...args)</td></tr>
<tr class="separator:ga8e85fddea6ef0ab8c90b00a39afb8044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eab34bf42bb316807cedebb527de857"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1eab34bf42bb316807cedebb527de857"></a>
template&lt;spawn_options Options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga1eab34bf42bb316807cedebb527de857"><td class="memTemplItemLeft" align="right" valign="top">typed_actor_ptr&lt; typename <br class="typebreak"/>
detail::deduce_signature&lt; Ts &gt;<br class="typebreak"/>
::type...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_typed</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Ts...&gt; &amp;me)</td></tr>
<tr class="separator:ga1eab34bf42bb316807cedebb527de857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abaf860ed7d1e8c075ffcc5ac3aaeb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5abaf860ed7d1e8c075ffcc5ac3aaeb0"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga5abaf860ed7d1e8c075ffcc5ac3aaeb0"><td class="memTemplItemLeft" align="right" valign="top">typed_actor_ptr&lt; typename <br class="typebreak"/>
detail::deduce_signature&lt; Ts &gt;<br class="typebreak"/>
::type...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_typed</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Ts...&gt; &amp;me)</td></tr>
<tr class="separator:ga5abaf860ed7d1e8c075ffcc5ac3aaeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467688df5583d9b7573ed3a09eb31bea"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga467688df5583d9b7573ed3a09eb31bea"></a>
template&lt;typename T0 , typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:ga467688df5583d9b7573ed3a09eb31bea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_typed</b> (T0 &amp;&amp;v0, T1 &amp;&amp;v1, Ts &amp;&amp;...vs) -&gt; decltype(spawn_typed(match_expr_collect(std::forward&lt; T0 &gt;(v0), std::forward&lt; T1 &gt;(v1), std::forward&lt; Ts &gt;(vs)...)))</td></tr>
<tr class="separator:ga467688df5583d9b7573ed3a09eb31bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3766bb0805c4b771f1b41d77f3f7a946"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_socket</b> = -1</td></tr>
<tr class="separator:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68b1f32b051c5cb7bcab4cab683da74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad68b1f32b051c5cb7bcab4cab683da74"></a>
static constexpr none_t&#160;</td><td class="memItemRight" valign="bottom"><b>none</b> = none_t{}</td></tr>
<tr class="separator:ad68b1f32b051c5cb7bcab4cab683da74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd601df8b1aff0ef276f80a103c5f4e"></a>
constexpr <a class="el" href="structcppa_1_1anything.html">anything</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> = <a class="el" href="structcppa_1_1anything.html">anything</a>{}</td></tr>
<tr class="memdesc:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any number of any values. <br/></td></tr>
<tr class="separator:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea202e88a810b28d8c7370c5e058277b"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a></td></tr>
<tr class="memdesc:aea202e88a810b28d8c7370c5e058277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>.  <a href="#aea202e88a810b28d8c7370c5e058277b">More...</a><br/></td></tr>
<tr class="separator:aea202e88a810b28d8c7370c5e058277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d615a84f0e0e4eede5087ace98adfb"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a46d615a84f0e0e4eede5087ace98adfb">on_arg_match</a></td></tr>
<tr class="memdesc:a46d615a84f0e0e4eede5087ace98adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression.  <a href="#a46d615a84f0e0e4eede5087ace98adfb">More...</a><br/></td></tr>
<tr class="separator:a46d615a84f0e0e4eede5087ace98adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241a516282529c45499a49101c35aa74"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>primitive_type_names</b> []</td></tr>
<tr class="separator:a241a516282529c45499a49101c35aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc77f5b27edd9e40908860db20e666d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc77f5b27edd9e40908860db20e666d"></a>
<a class="el" href="classcppa_1_1local__actor.html">local_actor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abdc77f5b27edd9e40908860db20e666d">self</a></td></tr>
<tr class="memdesc:abdc77f5b27edd9e40908860db20e666d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always points to the current actor. Similar to <code>this</code> in an object-oriented context. <br/></td></tr>
<tr class="separator:abdc77f5b27edd9e40908860db20e666d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae748daddf357a1e96ef0b444637b880f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae748daddf357a1e96ef0b444637b880f"></a>
static constexpr unit_t&#160;</td><td class="memItemRight" valign="bottom"><b>unit</b> = unit_t{}</td></tr>
<tr class="separator:ae748daddf357a1e96ef0b444637b880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33b8a52fd7db5b67b1ef54590a4915d4"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33b8a52fd7db5b67b1ef54590a4915d4">no_spawn_options</a> = spawn_options::no_flags</td></tr>
<tr class="memdesc:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br/></td></tr>
<tr class="separator:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f021447f0bf5ed017ecc7246d2a961f"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5f021447f0bf5ed017ecc7246d2a961f">monitored</a> = spawn_options::monitor_flag</td></tr>
<tr class="memdesc:a5f021447f0bf5ed017ecc7246d2a961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;monitor(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b05086b21ddcff1c3a65314d01923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9b05086b21ddcff1c3a65314d01923"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3b9b05086b21ddcff1c3a65314d01923">linked</a> = spawn_options::link_flag</td></tr>
<tr class="memdesc:a3b9b05086b21ddcff1c3a65314d01923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;link_to(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a3b9b05086b21ddcff1c3a65314d01923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e3d76a76f39ab461bb855a9317e7be3"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e3d76a76f39ab461bb855a9317e7be3">detached</a> = spawn_options::detach_flag</td></tr>
<tr class="memdesc:a3e3d76a76f39ab461bb855a9317e7be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt out of the cooperative scheduling. <br/></td></tr>
<tr class="separator:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85d3242470c0e518b8ba2009dadb09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c85d3242470c0e518b8ba2009dadb09"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1c85d3242470c0e518b8ba2009dadb09">hidden</a> = spawn_options::hide_flag</td></tr>
<tr class="memdesc:a1c85d3242470c0e518b8ba2009dadb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the runtime to ignore the new actor in <a class="el" href="namespacecppa.html#a185090573ffb146384ccdfa94172c23e">await_all_others_done()</a>. <br/></td></tr>
<tr class="separator:a1c85d3242470c0e518b8ba2009dadb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ec04cb57018987ad6bfe5df75a023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522ec04cb57018987ad6bfe5df75a023"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a522ec04cb57018987ad6bfe5df75a023">blocking_api</a> = spawn_options::blocking_api_flag</td></tr>
<tr class="memdesc:a522ec04cb57018987ad6bfe5df75a023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt in to the blocking API of libcppa, i.e., the actor uses a context-switching or thread-based backend instead of the default event-based implementation. <br/></td></tr>
<tr class="separator:a522ec04cb57018987ad6bfe5df75a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b11e888dffba9f5b2fbca37eb83069"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a47b11e888dffba9f5b2fbca37eb83069">priority_aware</a></td></tr>
<tr class="memdesc:a47b11e888dffba9f5b2fbca37eb83069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to evaluate message priorities.  <a href="#a47b11e888dffba9f5b2fbca37eb83069">More...</a><br/></td></tr>
<tr class="separator:a47b11e888dffba9f5b2fbca37eb83069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb4baa5b6eab7cb280b5d679741758e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb4baa5b6eab7cb280b5d679741758e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>channel_destination</b> = <a class="el" href="structcppa_1_1destination__header.html">destination_header</a>&lt; <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &gt;</td></tr>
<tr class="separator:a5fb4baa5b6eab7cb280b5d679741758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8966d7984c2ee203cf25e471a4e048"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8966d7984c2ee203cf25e471a4e048"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actor_destination</b> = <a class="el" href="structcppa_1_1destination__header.html">destination_header</a>&lt; <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &gt;</td></tr>
<tr class="separator:a9e8966d7984c2ee203cf25e471a4e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423658367b6100be9e3edd86509a1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2423658367b6100be9e3edd86509a1ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a2423658367b6100be9e3edd86509a1ea">send_tuple</a> (<a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a2423658367b6100be9e3edd86509a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> to the receiver specified in <code>hdr</code>. <br/></td></tr>
<tr class="separator:a2423658367b6100be9e3edd86509a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce9b9bc8666bd339ff6a95065b91d65"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ce9b9bc8666bd339ff6a95065b91d65"></a>
template&lt;typename... Signatures, typename... Ts&gt; </td></tr>
<tr class="memitem:a8ce9b9bc8666bd339ff6a95065b91d65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8ce9b9bc8666bd339ff6a95065b91d65">send</a> (const typed_actor_ptr&lt; Signatures...&gt; &amp;dest, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a8ce9b9bc8666bd339ff6a95065b91d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> to the receiver specified in <code>hdr</code>. <br/></td></tr>
<tr class="separator:a8ce9b9bc8666bd339ff6a95065b91d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fabc88e0a22ea360688bae581f7db6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:af4fabc88e0a22ea360688bae581f7db6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af4fabc88e0a22ea360688bae581f7db6">send</a> (<a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:af4fabc88e0a22ea360688bae581f7db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> to the receiver specified in <code>hdr</code>.  <a href="#af4fabc88e0a22ea360688bae581f7db6">More...</a><br/></td></tr>
<tr class="separator:af4fabc88e0a22ea360688bae581f7db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c461058940f6659192d4111067c11f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23c461058940f6659192d4111067c11f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a23c461058940f6659192d4111067c11f">send_tuple_as</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> from, <a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a23c461058940f6659192d4111067c11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> to <code>whom</code>, but sets the sender information to <code>from</code>. <br/></td></tr>
<tr class="separator:a23c461058940f6659192d4111067c11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93471700087f453e99d0eafa5c2868e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac93471700087f453e99d0eafa5c2868e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac93471700087f453e99d0eafa5c2868e">send_as</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> from, <a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:ac93471700087f453e99d0eafa5c2868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a message to <code>whom</code>, but sets the sender information to <code>from</code>.  <a href="#ac93471700087f453e99d0eafa5c2868e">More...</a><br/></td></tr>
<tr class="separator:ac93471700087f453e99d0eafa5c2868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdc6d1e1a5215278b74fbf807512ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abbdc6d1e1a5215278b74fbf807512ccf">sync_send_tuple</a> (<a class="el" href="structcppa_1_1destination__header.html">actor_destination</a> dest, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:abbdc6d1e1a5215278b74fbf807512ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a synchronous message to <code>whom</code>.  <a href="#abbdc6d1e1a5215278b74fbf807512ccf">More...</a><br/></td></tr>
<tr class="separator:abbdc6d1e1a5215278b74fbf807512ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fed05956552df0f3b6a0e2bf793ff9e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5fed05956552df0f3b6a0e2bf793ff9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5fed05956552df0f3b6a0e2bf793ff9e">sync_send</a> (<a class="el" href="structcppa_1_1destination__header.html">actor_destination</a> dest, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a5fed05956552df0f3b6a0e2bf793ff9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code>.  <a href="#a5fed05956552df0f3b6a0e2bf793ff9e">More...</a><br/></td></tr>
<tr class="separator:a5fed05956552df0f3b6a0e2bf793ff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bfc0b5f9c7f8ab4a1b18a3deb9716c"><td class="memTemplParams" colspan="2">template&lt;typename... Signatures, typename... Ts&gt; </td></tr>
<tr class="memitem:a36bfc0b5f9c7f8ab4a1b18a3deb9716c"><td class="memTemplItemLeft" align="right" valign="top">typed_message_future&lt; typename <br class="typebreak"/>
detail::deduce_output_type<br class="typebreak"/>
&lt; <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a><br class="typebreak"/>
&lt; Signatures...&gt;<br class="typebreak"/>
, <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; typename <br class="typebreak"/>
detail::implicit_conversions<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; Ts &gt;<br class="typebreak"/>
::type &gt;::type... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a36bfc0b5f9c7f8ab4a1b18a3deb9716c">sync_send</a> (const typed_actor_ptr&lt; Signatures...&gt; &amp;whom, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a36bfc0b5f9c7f8ab4a1b18a3deb9716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code>.  <a href="#a36bfc0b5f9c7f8ab4a1b18a3deb9716c">More...</a><br/></td></tr>
<tr class="separator:a36bfc0b5f9c7f8ab4a1b18a3deb9716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5554a3122b088c9455db775589e064fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5554a3122b088c9455db775589e064fd">delayed_send_tuple</a> (<a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> data)</td></tr>
<tr class="memdesc:a5554a3122b088c9455db775589e064fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="#a5554a3122b088c9455db775589e064fd">More...</a><br/></td></tr>
<tr class="separator:a5554a3122b088c9455db775589e064fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa849f068a2125dc342dadd74c330b570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa849f068a2125dc342dadd74c330b570">delayed_reply_tuple</a> (const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rel_time, <a class="el" href="classcppa_1_1message__id.html">message_id</a> mid, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> data)</td></tr>
<tr class="memdesc:aa849f068a2125dc342dadd74c330b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#aa849f068a2125dc342dadd74c330b570">More...</a><br/></td></tr>
<tr class="separator:aa849f068a2125dc342dadd74c330b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923189a2ec5fc59c21d98e204afb3ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae923189a2ec5fc59c21d98e204afb3ea">delayed_reply_tuple</a> (const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rel_time, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> data)</td></tr>
<tr class="memdesc:ae923189a2ec5fc59c21d98e204afb3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#ae923189a2ec5fc59c21d98e204afb3ea">More...</a><br/></td></tr>
<tr class="separator:ae923189a2ec5fc59c21d98e204afb3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fba8e0770e75b9a47755e0700803ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab9fba8e0770e75b9a47755e0700803ad">timed_sync_send_tuple</a> (<a class="el" href="structcppa_1_1destination__header.html">actor_destination</a> dest, const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ab9fba8e0770e75b9a47755e0700803ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a synchronous message to <code>whom</code> with a timeout.  <a href="#ab9fba8e0770e75b9a47755e0700803ad">More...</a><br/></td></tr>
<tr class="separator:ab9fba8e0770e75b9a47755e0700803ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46ae0aa8428bcb941c6fef7b54e2924"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad46ae0aa8428bcb941c6fef7b54e2924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad46ae0aa8428bcb941c6fef7b54e2924">timed_sync_send</a> (<a class="el" href="structcppa_1_1destination__header.html">actor_destination</a> whom, const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rtime, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:ad46ae0aa8428bcb941c6fef7b54e2924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code> with a timeout.  <a href="#ad46ae0aa8428bcb941c6fef7b54e2924">More...</a><br/></td></tr>
<tr class="separator:ad46ae0aa8428bcb941c6fef7b54e2924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a3d938a75401599d7de06573b8add2"><td class="memItemLeft" align="right" valign="top">CPPA_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa7a3d938a75401599d7de06573b8add2">reply_tuple</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:aa7a3d938a75401599d7de06573b8add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="#aa7a3d938a75401599d7de06573b8add2">More...</a><br/></td></tr>
<tr class="separator:aa7a3d938a75401599d7de06573b8add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f8b3addc14b7ac14ee76b9f77df06d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a70f8b3addc14b7ac14ee76b9f77df06d"><td class="memTemplItemLeft" align="right" valign="top">CPPA_DEPRECATED void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a70f8b3addc14b7ac14ee76b9f77df06d">reply</a> (Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a70f8b3addc14b7ac14ee76b9f77df06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="#a70f8b3addc14b7ac14ee76b9f77df06d">More...</a><br/></td></tr>
<tr class="separator:a70f8b3addc14b7ac14ee76b9f77df06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b7c1a13ac78822e3efc607b887664a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03b7c1a13ac78822e3efc607b887664a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a03b7c1a13ac78822e3efc607b887664a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a03b7c1a13ac78822e3efc607b887664a">reply_to</a> (const <a class="el" href="classcppa_1_1response__handle.html">response_handle</a> &amp;handle, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a03b7c1a13ac78822e3efc607b887664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message as reply to <code>handle</code>. <br/></td></tr>
<tr class="separator:a03b7c1a13ac78822e3efc607b887664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9a4dc7aa969b618f88f0571c0b8ea3d9">reply_tuple_to</a> (const <a class="el" href="classcppa_1_1response__handle.html">response_handle</a> &amp;handle, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replies with <code>what</code> to <code>handle</code>.  <a href="#a9a4dc7aa969b618f88f0571c0b8ea3d9">More...</a><br/></td></tr>
<tr class="separator:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb0df049b2846f2ee927d77f467ab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecb0df049b2846f2ee927d77f467ab4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aeecb0df049b2846f2ee927d77f467ab4">forward_to</a> (<a class="el" href="structcppa_1_1destination__header.html">actor_destination</a> dest)</td></tr>
<tr class="memdesc:aeecb0df049b2846f2ee927d77f467ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the last received message to <code>whom</code>. <br/></td></tr>
<tr class="separator:aeecb0df049b2846f2ee927d77f467ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0794637247bdee55e95638c34e21f9e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac0794637247bdee55e95638c34e21f9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac0794637247bdee55e95638c34e21f9e">delayed_send</a> (<a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rtime, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:ac0794637247bdee55e95638c34e21f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="#ac0794637247bdee55e95638c34e21f9e">More...</a><br/></td></tr>
<tr class="separator:ac0794637247bdee55e95638c34e21f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acf6c083e1b6cb9a2712f8249ea39c9"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a1acf6c083e1b6cb9a2712f8249ea39c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1acf6c083e1b6cb9a2712f8249ea39c9">delayed_reply</a> (const <a class="el" href="classcppa_1_1util_1_1duration.html">util::duration</a> &amp;rtime, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a1acf6c083e1b6cb9a2712f8249ea39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#a1acf6c083e1b6cb9a2712f8249ea39c9">More...</a><br/></td></tr>
<tr class="separator:a1acf6c083e1b6cb9a2712f8249ea39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab307a45c2227b2f81d1d987a20150694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab307a45c2227b2f81d1d987a20150694">send_exit</a> (<a class="el" href="structcppa_1_1destination__header.html">channel_destination</a> dest, std::uint32_t rsn)</td></tr>
<tr class="memdesc:ab307a45c2227b2f81d1d987a20150694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an exit message to <code>whom</code> with <code>reason</code>.  <a href="#ab307a45c2227b2f81d1d987a20150694">More...</a><br/></td></tr>
<tr class="separator:ab307a45c2227b2f81d1d987a20150694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8a86062680a8dd13b972684a698354"><td class="memTemplParams" colspan="2">template&lt;typename... Signatures&gt; </td></tr>
<tr class="memitem:a6b8a86062680a8dd13b972684a698354"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6b8a86062680a8dd13b972684a698354">send_exit</a> (const typed_actor_ptr&lt; Signatures...&gt; &amp;whom, std::uint32_t rsn)</td></tr>
<tr class="memdesc:a6b8a86062680a8dd13b972684a698354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an exit message to <code>whom</code> with <code>reason</code>.  <a href="#a6b8a86062680a8dd13b972684a698354">More...</a><br/></td></tr>
<tr class="separator:a6b8a86062680a8dd13b972684a698354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcppa. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9ed5b5aa07c384b14899beae80974d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> cppa::atom </td>
          <td>(</td>
          <td class="paramtype">char const (&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an atom from given string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String constant representing an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compact representation of <code>str</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a1">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a185090573ffb146384ccdfa94172c23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::await_all_others_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks execution of this actor until all other actors finished execution. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will cause a deadlock if called from multiple actors. </dd>
<dd>
Do not call this function in cooperatively scheduled actors. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a4">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a4">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a7">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a17">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a7">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1acf6c083e1b6cb9a2712f8249ea39c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply </td>
          <td>(</td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacecppa.html#ac0794637247bdee55e95638c34e21f9e" title="Sends a message to whom that is delayed by rel_time. ">delayed_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa849f068a2125dc342dadd74c330b570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply_tuple </td>
          <td>(</td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">message_id&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacecppa.html#ac0794637247bdee55e95638c34e21f9e" title="Sends a message to whom that is delayed by rel_time. ">delayed_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae923189a2ec5fc59c21d98e204afb3ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply_tuple </td>
          <td>(</td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacecppa.html#ac0794637247bdee55e95638c34e21f9e" title="Sends a message to whom that is delayed by rel_time. ">delayed_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac0794637247bdee55e95638c34e21f9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_send </td>
          <td>(</td>
          <td class="paramtype">channel_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a5">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5554a3122b088c9455db775589e064fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_send_tuple </td>
          <td>(</td>
          <td class="paramtype">channel_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">data</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa221547ef879ba5b42f7cc7820f90e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T cppa::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value. </p>
<p>Convenience function that deserializes a value from <code>what</code> and converts the result to <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>String representation of a serialized value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classcppa_1_1object.html">object</a> instance that contains the deserialized value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the result is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deserialized value as instance of <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a33344c46529f70febab48161c0c53a68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Types &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> cppa::get_wildcard_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>template parameter pack as <a class="el" href="structcppa_1_1util_1_1type__list.html">type_list</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28cd5b37281764af3f24ba8ca297c2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> cppa::make_any_tuple </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values to initialize the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad65859efc090932630d14b226b9c9624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa18a8117e9022caea2b0606c11ebbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ca31369f494fd492be6de8bec9d96d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator&gt; cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches each element in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a35b5c639c9579b617662e3de649ed0cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Projection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator, Projection&gt; cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Projection&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
    <tr><td class="paramname">proj</td><td>Projection or extractor functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a25d0d9e15f20fe8a0644a1d137d27e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches values. </p>
<p>This overload can be used with the wildcards <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>, <a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> and <a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a3">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb8c5c063a1758690748e20c805a76aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches types only. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a1341cd8bd16f4821146053de1093a732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atom_value... Atoms, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches up to four leading atoms. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a487e6c08f5f4f7de4775418547f7e93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> at <code>port</code>. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">port</td><td>Unused TCP port. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address to listen to, or <code>INADDR_ANY</code> if <code>addr</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7de4c76a41489b5391c1b9cd24b2e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; io::acceptor &gt;&#160;</td>
          <td class="paramname"><em>acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">acceptor</td><td>Network technology-specific acceptor implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae213a56201820111919afe92aa287586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish_local_groups_at </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classcppa_1_1network__error.html" title="Thrown to indicate that either an actor publishing failed or libcppa was unable to connect to a remot...">network_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76739f7f372b92999ee9b80d332093bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e44ab5ef88ac98dd909f3a09bbf181d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3ba6593cce62eab364a52c5a9a7bb27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">io::stream_ptr_pair&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor via given <code>connection</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>A connection to another libcppa process described by a pair of input and output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a70f8b3addc14b7ac14ee76b9f77df06d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPPA_DEPRECATED void cppa::reply </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the sender of the last received message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7a3d938a75401599d7de06573b8add2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPPA_DEPRECATED void cppa::reply_tuple </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the sender of the last received message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a4dc7aa969b618f88f0571c0b8ea3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::reply_tuple_to </td>
          <td>(</td>
          <td class="paramtype">const response_handle &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replies with <code>what</code> to <code>handle</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Identifies a previously received request. </td></tr>
    <tr><td class="paramname">what</td><td>Response message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4fabc88e0a22ea360688bae581f7db6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send </td>
          <td>(</td>
          <td class="paramtype">channel_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> to the receiver specified in <code>hdr</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac93471700087f453e99d0eafa5c2868e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send_as </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">channel_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a message to <code>whom</code>, but sets the sender information to <code>from</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Sender as seen by <code>whom</code>. </td></tr>
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab307a45c2227b2f81d1d987a20150694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send_exit </td>
          <td>(</td>
          <td class="paramtype">channel_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>rsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an exit message to <code>whom</code> with <code>reason</code>. </p>
<p>This function is syntactic sugar for <code>send(whom, atom("EXIT"), reason)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>reason != <a class="el" href="namespacecppa_1_1exit__reason.html#a68daf41064e58fe0302ca3becc85357d" title="Indicates that an actor finished execution. ">exit_reason::normal</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8a86062680a8dd13b972684a698354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Signatures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send_exit </td>
          <td>(</td>
          <td class="paramtype">const typed_actor_ptr&lt; Signatures...&gt; &amp;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>rsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an exit message to <code>whom</code> with <code>reason</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>reason != <a class="el" href="namespacecppa_1_1exit__reason.html#a68daf41064e58fe0302ca3becc85357d" title="Indicates that an actor finished execution. ">exit_reason::normal</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2a11054c90870f7f7bae3117845127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::set_default_scheduler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a thread pool scheduler with <code>num_threads</code> worker threads. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there's already a scheduler defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fd959a7ff3c017ded6b64ee72dcec97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::set_scheduler </td>
          <td>(</td>
          <td class="paramtype">scheduler *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scheduler to <code>sched</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>A user-defined scheduler implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sched != nullptr</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there's already a scheduler defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5874085dfe88492adbc380b55c77053f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a733d5a4394026abf6ddaba265f6970e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d7ec2cc77f30d3921a26fa21b902075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae91e347999ca21eaf734024e45eff768"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a187a8a85be51fbecff49379ecaeacca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_io </td>
          <td>(</td>
          <td class="paramtype">io::input_stream_ptr&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::output_stream_ptr&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns an IO actor of type <code>Impl</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Impl</td><td>Subtype of <a class="el" href="classcppa_1_1io_1_1broker.html">io::broker</a>. </td></tr>
    <tr><td class="paramname">Options</td><td>Optional flags to modify <code>spawn</code>'s behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the spawned <a class="el" href="classcppa_1_1actor.html">actor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cf2717df3f8bf104c6910e26f30833a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;spawn_options Options = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_io </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::input_stream_ptr&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::output_stream_ptr&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new <a class="el" href="classcppa_1_1actor.html">actor</a> that evaluates given arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A functor followed by its arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Options</td><td>Optional flags to modify <code>spawn</code>'s behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the spawned <a class="el" href="classcppa_1_1actor.html">actor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fed05956552df0f3b6a0e2bf793ff9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::sync_send </td>
          <td>(</td>
          <td class="paramtype">actor_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a synchronous message to <code>whom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36bfc0b5f9c7f8ab4a1b18a3deb9716c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Signatures, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typed_message_future&lt; typename detail::deduce_output_type&lt; <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt;Signatures...&gt;, <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; typename detail::implicit_conversions&lt; typename <a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; Ts &gt;::type &gt;::type... &gt; &gt;::type&gt; cppa::sync_send </td>
          <td>(</td>
          <td class="paramtype">const typed_actor_ptr&lt; Signatures...&gt; &amp;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a synchronous message to <code>whom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbdc6d1e1a5215278b74fbf807512ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::sync_send_tuple </td>
          <td>(</td>
          <td class="paramtype">actor_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>what</code> as a synchronous message to <code>whom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad46ae0aa8428bcb941c6fef7b54e2924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::timed_sync_send </td>
          <td>(</td>
          <td class="paramtype">actor_destination&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a synchronous message to <code>whom</code> with a timeout. </p>
<p>The calling actor receives a 'TIMEOUT' message as response after given timeout exceeded and no response messages was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9fba8e0770e75b9a47755e0700803ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::timed_sync_send_tuple </td>
          <td>(</td>
          <td class="paramtype">actor_destination&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const util::duration &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>what</code> as a synchronous message to <code>whom</code> with a timeout. </p>
<p>The calling actor receives a 'TIMEOUT' message as response after given timeout exceeded and no response messages was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receiver and optional priority flag. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76a9f2873d0e97eb7ceffb6101e8e507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppa::to_string </td>
          <td>(</td>
          <td class="paramtype">const atom_value &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>what</code> as a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Compact representation of an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>what</code> as string. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_4_8cpp-example.html#a2">announce_4.cpp</a>, and <a class="el" href="announce_5_8cpp-example.html#a11">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af928936d573122345bc0737615f95f33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches any value of type <code>T</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a0">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a0">announce_3.cpp</a>, and <a class="el" href="announce_4_8cpp-example.html#a0">announce_4.cpp</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aea202e88a810b28d8c7370c5e058277b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a4">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a46d615a84f0e0e4eede5087ace98adfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::on_arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression. </p>
<p>Equal to <code>on(arg_match)</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_5_8cpp-example.html#a10">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a241a516282529c45499a49101c35aa74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* cppa::primitive_type_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;pt_int8&quot;</span>,        <span class="stringliteral">&quot;pt_int16&quot;</span>,       <span class="stringliteral">&quot;pt_int32&quot;</span>,       <span class="stringliteral">&quot;pt_int64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_uint8&quot;</span>,       <span class="stringliteral">&quot;pt_uint16&quot;</span>,      <span class="stringliteral">&quot;pt_uint32&quot;</span>,      <span class="stringliteral">&quot;pt_uint64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_float&quot;</span>,       <span class="stringliteral">&quot;pt_double&quot;</span>,      <span class="stringliteral">&quot;pt_long_double&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_u8string&quot;</span>,    <span class="stringliteral">&quot;pt_u16string&quot;</span>,   <span class="stringliteral">&quot;pt_u32string&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_atom&quot;</span>,        <span class="stringliteral">&quot;pt_null&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47b11e888dffba9f5b2fbca37eb83069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a> cppa::priority_aware</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= spawn_options::priority_aware_flag</div>
<div class="line">                                         + spawn_options::detach_flag</div>
</div><!-- fragment -->
<p>Causes the new actor to evaluate message priorities. </p>
<dl class="section note"><dt>Note</dt><dd>This implicitly causes the actor to run in its own thread. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 14 2013 20:08:20 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
